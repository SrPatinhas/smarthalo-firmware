// ------------------------------------------------------------------------------------------------
/*!@file    CommunicationTask.c
 */
// ------------------------------------------------------------------------------------------------
#include <CommunicationTask.h>
#include <SoundTask.h>
#include "main.h"
#include <stdio.h>
#include <string.h>
#include <SystemUtilitiesTask.h>
#include "SubscriptionHelper.h"

#include "GraphicsTask.h"
#include "BLEDriver.h"
#include "usart.h"
#include "HaloLedsDriver.h"
#include "BootLoaderImport.h"
#include "SensorsTask.h"
#include "HardwareTests.h"
#include "reboot.h"
#include "Power.h"
#include "WatchdogTask.h"
#include "device_telemetry.h"
#include "SHTaskUtils.h"

// ================================================================================================
// ================================================================================================
//            PRIVATE DEFINE DECLARATION
// ================================================================================================
// ================================================================================================
#define QUEUE_LENGTH 4
#define STACK_SIZE (configMINIMAL_STACK_SIZE*2 + 256)

#define TASK_PRIORITY 	PRIORITY_NORMAL

#define CONNECTION_SUBSCRIPTION_LIMIT 7
#define PAIRED_SUBSCRIPTION_LIMIT 5

// ================================================================================================
// ================================================================================================
//            PRIVATE MACRO DEFINITION
// ================================================================================================
// ================================================================================================

// ================================================================================================
// ================================================================================================
//            PRIVATE ENUM DEFINITION
// ================================================================================================
// ================================================================================================

// ================================================================================================
// ================================================================================================
//            PRIVATE STRUCTURE DECLARATION
// ================================================================================================
// ================================================================================================
typedef struct {
    uint8_t 	status;
    uint8_t		nordicVersion[4];
    uint8_t		nordicBootLoader[4];
    uint8_t 	hw;
    uint8_t 	meters;
    uint8_t		stmVersion[4];
    blVersion_t	stmBLVersion;
} __attribute__ ((packed)) VersionReply_t;

// ================================================================================================
// ================================================================================================
//            PRIVATE VARIABLE DECLARATION
// ================================================================================================
// ================================================================================================

static TaskHandle_t selfHandle;
static StaticTask_t xTaskBuffer;
static StackType_t	CommTaskStack[STACK_SIZE];

#ifdef FWVERSION // defined ONLY by IDE builds, which are not for release
uint8_t version[4] = { FWVERSION };
#else
extern uint8_t version[4]; // contents defined in fwversion.c (generated by mkversion.sh)
#endif

static uint8_t connectionStateSubscribers = 0;
static uint8_t pairedStateSubscribers = 0;
static bool isAuthenticated = false;

static eStandbyReason_t standbyReason = StandbyOff;
static bool changeStandby = false;

void (*authFunctions[AUTH_ENUM_SIZE])(uint16_t, uint8_t *);
void (*uiFunctions[UI_ENUM_SIZE])(uint16_t, uint8_t *);
void (*soundFunctions[SOUND_ENUM_SIZE])(uint16_t, uint8_t *);
void (*alarmFunctions[ALARM_ENUM_SIZE])(uint16_t, uint8_t *);
void (*deviceFunctions[DEVICE_ENUM_SIZE])(uint16_t, uint8_t *);
void (*testFunctions[TEST_ENUM_SIZE])(uint16_t, uint8_t *);
void (*experimentalFunctions[EXP_ENUM_SIZE])(uint16_t, uint8_t *);
void (**functions[COM_ENUM_SIZE])(uint16_t,uint8_t *) =
{authFunctions, uiFunctions, soundFunctions, alarmFunctions, deviceFunctions, testFunctions, experimentalFunctions};

void (*connectionSubscriptions[CONNECTION_SUBSCRIPTION_LIMIT])(bool isConnected);
void (*pairedSubscriptions[PAIRED_SUBSCRIPTION_LIMIT])(bool isPaired);

const char        standbyFile[]       = "StandbyState";

// ================================================================================================
// ================================================================================================
//            PRIVATE FUNCTION DECLARATION
// ================================================================================================
// ================================================================================================
static void prvCommTask(void *pvParameters);

// ================================================================================================
// ================================================================================================
//            PUBLIC FUNCTION SECTION
// ================================================================================================
// ================================================================================================

/**
 * @brief Subscribe to the connection state
 * @details Add a function to subscribe to any changes in the connection state
 */
void subscribeToConnectionState_CommunicationTask(void (*function)(bool isConnected)){
    addSubscription((void *) connectionSubscriptions,
            &connectionStateSubscribers,
            CONNECTION_SUBSCRIPTION_LIMIT,
            "Connection",
            function);
}

/**
 * @brief Unsubscribe from connection state
 * @details Remove a subscription from the connection state to no longer get updates
 */
void unsubscribeToConnectionState_CommunicationTask(void (*function)(bool isConnected)){
    removeSubscription((void *) connectionSubscriptions,
            &connectionStateSubscribers,
            "Connection",
            function);
}

/**
 * @brief Subscribe to the paired state
 * @details Add a function to subscribe to any changes in the connection state
 */
void subscribeToPairedState_CommunicationTask(void (*function)(bool isPaired)){
    addSubscription((void *) pairedSubscriptions,
            &pairedStateSubscribers,
            PAIRED_SUBSCRIPTION_LIMIT,
            "Paired",
            function);
}

/**
 * @brief Unsubscribe from connection state
 * @details Remove a subscription from the connection state to no longer get updates
 */
void unsubscribeToPairedState_CommunicationTask(void (*function)(bool isPaired)){
    removeSubscription((void *) pairedSubscriptions,
            &pairedStateSubscribers,
            "Paired",
            function);
}

/**
 * @brief Assign a message type to a function
 * @details Sends message payload to the assigned function, will overwrite any existing assignments
 */
void assignFunction_CommunicationTask(eComCategory_t category, uint8_t type, void * function){
    uint8_t shiftedCategory = category == COM_TEST ? 5 : category == COM_EXP ? 6 : category;
    functions[shiftedCategory][type] = function;
}

/**
 * @brief       Initialize the Communication Task
 * @details		Setup the BLE Driver and setup the task.
 * @public
 */
void init_CommunicationTask() {
    init_BLEDriver();
    init_HardwareTests();

    if (selfHandle == NULL) {
        selfHandle = xTaskCreateStatic(prvCommTask, TASKNAME_COMMUNICATION,
                STACK_SIZE, NULL, TASK_PRIORITY, CommTaskStack, &xTaskBuffer);
        configASSERT(selfHandle);
    }

}

/**
 * @brief Get the reason for standby mode
 */
eStandbyReason_t getStandbyReason_CommunicationTask(){
    return standbyReason;
}

/**
 * @brief Enter standby mode for BLE
 * @details Standby mode will toggle from this call
 */
void toggleStandby_CommunicationTask(eStandbyReason_t reason){
    standbyReason = reason;
    changeStandby = true;
    writeFile_SystemUtilities(standbyFile, &standbyReason, 1);
}

uint8_t * getVersion_CommunicationTask() {
    return version;
}

/**
 * @brief       Interpret a BLE message
 * @details     Send the BLE message and its payload to a subscribed function or
 *              return "unimplemented" BLE message if there is not subscriber
 * @param[in]	msg the received packet
 * @return      true on success
 */
bool interpret_CommunicationTask(oBLERXMessage_t *msg)
{
    // uint8_t messageType = msg->msg_type;
    uint8_t messageCmd = msg->msg_cmd;
    uint8_t *data = msg->data;
    uint16_t messageLength = msg->size;

    eComCategory_t 	eComCategory 	= data[0];

    if (data == NULL)
        genericResponse_CommunicationTask(eCOM_RETURN_STATUS_FAIL);

    // RX BLE
    if (messageCmd == BLE_RX_COMMAND_BLE){
        // log_Shell("%s: received message, poking wakeForUI", __func__);
        stayAwake_Power(__func__);
        if(eComCategory != COM_AUTH && !isAuthenticated){
            log_Shell("%s: unauthenticated command, category: %x", __func__, eComCategory);
            deniedResponse_CommunicationTask(DENY_UNAUTHENTICATED);

            return true;
        }
        uint8_t type = data[1];
        uint8_t category = eComCategory;
        uint8_t limit = 0;
        switch(eComCategory){
            case COM_AUTH:
                limit = AUTH_ENUM_SIZE;
                break;
            case COM_UI:
                limit = UI_ENUM_SIZE;
                break;
            case COM_SOUND:
                limit = SOUND_ENUM_SIZE;
                break;
            case COM_ALARM:
                limit = ALARM_ENUM_SIZE;
                break;
            case COM_DEVICE:
                limit = DEVICE_ENUM_SIZE;
                break;
            case COM_TEST:
                limit = TEST_ENUM_SIZE;
                category = 5;
                break;
            case COM_EXP:
                limit = EXP_ENUM_SIZE;
                category = 6;
                break;
            default:
                limit = 0; //Shouldn't happen, if it does always return unsupported
                break;
        }
        if(category >= COM_ENUM_SIZE || type >= limit || functions[category][type] == NULL){
            // unsupported command.
            log_Shell("Unsupported Command category: %x type: %x",eComCategory, data[1]);
            genericResponse_CommunicationTask(eCOM_RETURN_STATUS_UNIMPLEMENTED);
        }else{
            // log_Shell("%s: dispatching %x:%x", __func__, category, type);
            (functions[category][type])(messageLength-2, &data[2]);
        }
    }else if(messageCmd == BLE_COMMAND_SYNC){
        UART_SYNC_E syncEnums = data[0];
        switch(syncEnums){
            case BLE_SET_BOOTLOADER:{
                log_Shell("Sent to Nordic Bootloader!");
                genericResponse_CommunicationTask(eCOM_RETURN_STATUS_OK);
                break;
            }
            case BLE_CONNECTION_STATE:{
                log_Shell("%s: sync connection state: %s", __func__, data[1] ? "true" : "false");
                isAuthenticated = data[1] ? true : false;
                for(int i=0;i<connectionStateSubscribers;i++){
                    connectionSubscriptions[i](isAuthenticated);
                }
                if (isAuthenticated) {
                    log_deviceTelemetry(eCONNECT, 0);
                } else {
                    uint8_t reason = 0;
                    if (messageLength == 3) {
                        reason = data[2];
                        log_Shell("%s: disconnect reason code: 0x%x", __func__, reason);
                    }
                    log_deviceTelemetry(eDISCONNECT, reason);
                }
                break;
            }
            case BLE_SET_NAME:{
                genericResponse_CommunicationTask(eCOM_RETURN_STATUS_OK);
                break;
            }
            case BLE_GET_VERSIONS:{
                VersionReply_t 	response;
                response.status = eCOM_RETURN_STATUS_OK;
                memcpy(response.nordicVersion, data + 1, messageLength - 1);
                response.hw = 2;
                response.meters = 0;
                memcpy(response.stmVersion, version, sizeof(version));
                response.stmBLVersion.blVersion = __REV(MCB->version.blVersion);
                sendData_CommunicationTask(BLE_TYPE_MSG, BLE_TX_COMMAND_BLE_RESPONSE, sizeof(response), &response);
                break;
            }
            case BLE_GET_ID:{
                uint8_t length = messageLength-1;
                uint8_t response[length];
                for(int i=0;i<messageLength;i++){
                    response[i] = data[i];
                }

                printDeviceID_DebugConsole(&response[1], length);
                break;
            }
            case BLE_PAIRED_STATE:{
                for(int i=0;i<pairedStateSubscribers;i++){
                    pairedSubscriptions[i](data[1] ? true : false);
                }
                if (data[1]) {
                    log_deviceTelemetry(ePAIR, 0);
                } else {
                    log_deviceTelemetry(eUNPAIR, 0);
                }
                break;
            }
            default:{
                log_Shell("Unsupported Command %d",data[1]);
                // unsupported command.
                genericResponse_CommunicationTask(eCOM_RETURN_STATUS_UNIMPLEMENTED);
                break;
            }
        }
    }
    return true;
}

/**
 * @brief       Send a response via BLE
 * @details     This response should include the first byte as a response status and the rest is the response payload.
 * @public
 * @param[in]	type: Type to send.
 * @param[in]	command: Command of the packet.
 * @param[in]	length: number of byte to send.
 * @param[out] 	data: ptr of the data to send.
 * @return      bool: true if success, false otherwise.
 * */
bool sendData_CommunicationTask(uint8_t type, uint8_t command, uint16_t length, void *data){
    if (data == NULL) return false;

    oBLETXMessage_t ble_msg;
    ble_msg.msg_type = type;
    ble_msg.msg_cmd = command;
    ble_msg.size = length;

    memcpy(ble_msg.data, data, length);

    tx_BLEDriver(&ble_msg);

    return true;
}

/**
 * @brief Send response via BLE with extra data
 * @details This is a response with any size of payload
 */
void responseWithPayload_CommunicationTask(uint16_t length, void * data){
    sendData_CommunicationTask(BLE_TYPE_MSG, BLE_TX_COMMAND_BLE_RESPONSE, length, data);
}

/**
 * @brief Send denied response with a reason
 * @details The given reason will be appended to the denied response for the consumer to know
 */
void deniedResponse_CommunicationTask(eDenyReason_t reason){
    uint8_t ble_msg[2];
    ble_msg[0] = eCOM_RETURN_STATUS_DENIED;
    ble_msg[1] = reason;

    sendData_CommunicationTask(BLE_TYPE_MSG, BLE_TX_COMMAND_BLE_RESPONSE, 2, ble_msg);
}

/**
 * @brief   Send response via BLE
 * @details The status will send a simple response with a status type and no payload
 */
void genericResponse_CommunicationTask(eCOM_RETURN_STATUS_t status){
    uint8_t ble_msg[1];
    ble_msg[0] = status;

    sendData_CommunicationTask(BLE_TYPE_MSG, BLE_TX_COMMAND_BLE_RESPONSE, 1, ble_msg);
}

/**
 * @brief Send response via BLE
 * @details The response is based on a boolean indicating the success of a msg
 */
void responseFromResult_CommunicationTask(bool bResult){
    if (bResult == true){
        genericResponse_CommunicationTask(eCOM_RETURN_STATUS_OK);
    } else {
        genericResponse_CommunicationTask(eCOM_RETURN_STATUS_FAIL);
    }
}

/**
 * @brief       function to enable the OLED for testing
 * @details     turns on all the pixels of the OLED
 */
void testOledDisplay_CommunicationTask(){
    oled_cmd_t oledCMD;
    oledCMD.statusBarPosition = -1;
    oledCMD.direction = oled_no_animation;
    oledCMD.animationTypeMask = slidingAnimation;
    oledCMD.animation = false;
    oledCMD.u8ImageCategory = oled_tests;
    oledCMD.u8ImageType = oled_test_display;
    setImage_GraphicsTask(&oledCMD);
}

// ================================================================================================
// ================================================================================================
//            PRIVATE FUNCTION SECTION
// ================================================================================================
// ================================================================================================

uint32_t commTaskCount;

static void prvCommTask(void *pvParameters){
    eStandbyReason_t savedReason;
    if(readFile_SystemUtilities(standbyFile, &savedReason, 1)){
        standbyReason = savedReason;
        if(standbyReason != StandbyOff)
            toggleStandby_BLEDriver(standbyReason);
    }

    while (1) {
        commTaskCount++;
        vTaskDelay(100);
        checkUART_BLEDriver();
        if (((commTaskCount % 20) == 0) && isAuthenticated) {
            upload_deviceTelemetry();
        }
        if(changeStandby){
            toggleStandby_BLEDriver(standbyReason);
            changeStandby = false;
        }
        shwd_KeepAlive(eSHWD_CommunicationTask);
    }
}
