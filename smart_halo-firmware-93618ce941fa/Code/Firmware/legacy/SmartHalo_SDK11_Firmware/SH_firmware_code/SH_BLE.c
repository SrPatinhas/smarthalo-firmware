//==========================================//
//		MANAGEMENT OF IN-HOUSE PROTOCOL
//			FOR BLUETOOTH LOW ENERGY
//==========================================//
#include <stdint.h>
#include <string.h>
#include "nordic_common.h"
#include "nrf.h"
#include "app_error.h"
#include "ble.h"
#include "ble_hci.h"
#include "ble_srv_common.h"
#include "ble_advdata.h"
#include "ble_advertising.h"
#include "ble_bas.h"
#include "ble_hrs.h"
#include "ble_dis.h"
#ifdef BLE_DFU_APP_SUPPORT
#include "ble_dfu.h"
#include "dfu_app_handler.h"
#endif // BLE_DFU_APP_SUPPORT
#include "ble_conn_params.h"
#include "boards.h"
#include "sensorsim.h"
#include "softdevice_handler.h"
#include "app_timer.h"
#include "device_manager.h"
#include "pstorage.h"
#include "app_trace.h"
#include "bsp.h"
#include "nrf_delay.h"
#include "nrf_gpio.h"
#include "app_util_platform.h"
#include "SH_BLE.h"
#include "crc.h"
#include "ble_nus.h"
#include "ble_gatts.h"
#include "SHP_Frames_and_commands.h"
#include "SH_Priority_queue.h"
#include "SH_Primary_state_machine.h"
#include "SH_typedefs.h"
#include "app_uart.h"


//==========================================//
//GLOBAL VARIABLES , get rid of these
// made global and static for memory management purposes
//static uint8_t BLE_message_buffer[MAX_BUFFER_SIZE];
static bool error_messages_sendback[NUMBER_OF_POSSIBLE_ERRORS];

//extern crc  crcTable[256];//table generated by crcInit() to calculate the crc
//==========================================//


//==========================================//
//PRIVATE STATIC FUNCTION DECLARATIONS

//static void manage_memory();
static SH_BLE_message_t SH_BLE_protocol_framing_state_machine(char* SH_BLE_message);
static void error_management(uint8_t);

//static void send_SH_BLE_message();
//==========================================//


//==========================================//
//PUBLIC FUNCTIONS





void manage_SH_BLE_messages(SHP_message_buffer_t* input_message_list,SHP_command_buffer_t* LOW_priority_output_command_list, SHP_command_buffer_t* HIGH_priority_output_command_list)//char* SH_BLE_message)
{
	while(input_message_list->rear >= 0)
	{
		SH_BLE_message_t parsed_message =
		{
			.message_error = 0
		};

		//retrieve message, store in buffer, parse it, and send the informations to the appropriate locations
		parsed_message = SH_BLE_protocol_framing_state_machine(input_message_list->queue_array[0]);
		if(!parsed_message.message_error)
		{
			//message must be managed if no errors
			insert_command(HIGH_priority_output_command_list, &parsed_message);
			delete_unparsed_message(input_message_list);
		}
		else
		{
			/*
			SH_BLE_message_t error_message;
			//uint8_t number_of_errors;
			error_message.message_error = 1;
			error_message.device_address = 0x65;//"e";
			error_message.destination_address = 0x72;// "r";
			error_message.protocol_version = 0x72;//"r";
			error_message.lentgh = 0x6F;//"o";
			error_message.command = 0x72;//"r";
			error_message.data[0] = 0x3A;//":";


			//send back number of first error found
			for(uint8_t i = 0; i < NUMBER_OF_POSSIBLE_ERRORS; i++)
			{
				if(error_messages_sendback[i])
				{
					error_message.data[1] = i;
					break;
				}
			}*/
			delete_unparsed_message(input_message_list);
			//return error_message;
		}

		//send_BLE_report();	//send error message back for confirmation of proper reception
	//return 0;
	}
}


bool SH_BLE_init()
{
	 crcInit();//create lookup table for the checksum
	// manage_memory();
	 send_BLE_report();
	return 0;//error message may not be necessary
}

bool ready_to_receive()
{
	//function to let the device know that we are ready to receive information
	//send a bluetooth message blurb to the device
return 0;
}

void send_BLE_report()
{
	//send a string or a stored value
	//to represent all the encountered errors
	//or a message of confirmation of reception
	for(uint8_t j = 0; j < NUMBER_OF_POSSIBLE_ERRORS - 1; j++ )
	{
		error_messages_sendback[j] = 0;
	}



}

void send_BLE_command_and_data(ble_nus_t * p_nus, uint8_t command, uint8_t length, uint8_t* data)
{
	if(get_gap_is_connected_flag())
	{
		if(length < 1) return;

		uint8_t SH_BLE_to_send[MAX_PACKET_LENGTH];
		SH_BLE_to_send[SOF_FRAME] = START_OF_FRAME_VALUE;
		SH_BLE_to_send[SRC_FRAME] = 0x00;
		SH_BLE_to_send[DST_FRAME] = 0x00;
		SH_BLE_to_send[VER_LEN_FRAME] = length;//(message_to_send->protocol_version << 4) & lentgh;

		SH_BLE_to_send[MTYP_FRAME] = command; //message_to_send->command;

		for(int i =0; i<length; ++i)
		{
			SH_BLE_to_send[MSG_FRAME+i] = data[i];
		}
		SH_BLE_to_send[MTYP_FRAME + 0x03 + length]= END_OF_FRAME_VALUE;//message_to_send->lentgh] = END_OF_FRAME_VALUE;

		ble_nus_string_send(p_nus, SH_BLE_to_send, MAX_PACKET_LENGTH);
	}
}



void send_confirmation_of_reception(ble_nus_t * p_nus, uint8_t confirmed_command)
{
	if(get_gap_is_connected_flag())
	{
		uint8_t SH_BLE_to_send[MAX_PACKET_LENGTH];
		SH_BLE_to_send[SOF_FRAME] = START_OF_FRAME_VALUE;
		SH_BLE_to_send[SRC_FRAME] = 0x00;
		SH_BLE_to_send[DST_FRAME] = 0x00;
		SH_BLE_to_send[VER_LEN_FRAME] = 0x03;//(message_to_send->protocol_version << 4) & message_to_send->lentgh;
		//SH_BLE_to_send[LEN_FRAME] = ;
	//	if(message_to_send->lentgh > 0)
	//	{
		SH_BLE_to_send[MTYP_FRAME] = confirmed_command; //message_to_send->command;
	//		for(uint8_t i = 0; i < message_to_send->lentgh; i++)
	//		{
	//			SH_BLE_to_send[MSG_FRAME+i] = message_to_send->data[i];
	//		}
	//	}
		SH_BLE_to_send[MTYP_FRAME + 0x03]= END_OF_FRAME_VALUE;//message_to_send->lentgh] = END_OF_FRAME_VALUE;

		ble_nus_string_send(p_nus, SH_BLE_to_send, MAX_PACKET_LENGTH);
	}

}





const uint8_t* get_SH_BLE_message()
{
	const uint8_t*  message_handle = 0;

	//BLE_message_buffer = SH_BLE_message;
	//memcpy(BLE_message_buffer, SH_BLE_message,sizeof(SH_BLE_message));
	//chop up the message and store in the BLE_message_buffer
	//check for little or big endian?
	//put message into the pointer. make pointer constant so that same bloc of memory always used
	//memory bloc must be erased.

	return message_handle;
}


//==========================================//


//==========================================//
//PRIVATE FUNCTIONS







/*static*/ void send_SH_BLE_message(ble_nus_t * p_nus, SH_BLE_message_t* message_to_send)// send message using the in house protocol to central device
{
	//sd_ble_gatts_hvx(conn_handle, &hvx_params);

	//convert message structure to string
	uint8_t SH_BLE_to_send[MAX_PACKET_LENGTH];
	SH_BLE_to_send[SOF_FRAME] = START_OF_FRAME_VALUE;
	SH_BLE_to_send[SRC_FRAME] = message_to_send->device_address;
	SH_BLE_to_send[DST_FRAME] = message_to_send->destination_address;
	SH_BLE_to_send[VER_LEN_FRAME] = (message_to_send->protocol_version << 4) & message_to_send->lentgh;
	//SH_BLE_to_send[LEN_FRAME] = ;
	if(message_to_send->lentgh > 0)
	{
		SH_BLE_to_send[MTYP_FRAME] = message_to_send->command;
		for(uint8_t i = 0; i < message_to_send->lentgh; i++)
		{
			SH_BLE_to_send[MSG_FRAME+i] = message_to_send->data[i];
		}
	}
	SH_BLE_to_send[MTYP_FRAME + message_to_send->lentgh] = END_OF_FRAME_VALUE;

	ble_nus_string_send(p_nus, SH_BLE_to_send, MAX_PACKET_LENGTH);

}

//see latest version of SHP Protocol Specification document for more details
//TO DO: ADD EXPLANATION HERE, explain parameters and objective of functions
static SH_BLE_message_t SH_BLE_protocol_framing_state_machine(char* SH_BLE_message)
{
	SH_BLE_message_t parsed_message;
	SH_BLE_message_t error_message;
	uint8_t infinite_loop_check = MAX_LOOP_CYCLES;
	uint8_t frame_state = START_OF_FRAME_STATE;
	uint8_t msg_length = 0;
	bool state_machine_is_active = true;

	//make sure that this cannot exceed the end of the message to avoid assert failure for buffer size
	while(state_machine_is_active)
	{
		infinite_loop_check --;
		if (!infinite_loop_check)
		{
			error_management(INFINITE_LOOP);
			parsed_message.message_error = true;
			return parsed_message;
		}
		switch (frame_state)//frame state machine
		{
			case START_OF_FRAME_STATE:
				//parse first byte of message here for SOF
				if(SH_BLE_message[SOF_FRAME] == START_OF_FRAME_VALUE) frame_state = SOURCE_ADDRESS_STATE;
				else
				{
					frame_state = START_OF_FRAME_STATE;
					state_machine_is_active = STATE_MACHINE_EXIT_CONDITION;
					error_management(START_OF_FRAME_INCORRECT);
				}
				break;

			case SOURCE_ADDRESS_STATE:
				//if(/*address found*/)
				//{
					parsed_message.device_address =  SH_BLE_message[SRC_FRAME];
					frame_state = DESTINATION_ADDRESS_STATE;
			//	}
//				else
//				{
//					frame_state = START_OF_FRAME_STATE;
//					state_machine_is_active = STATE_MACHINE_EXIT_CONDITION;
//					error_management(UNDEFINED_SOURCE_ADDRESS);
//				}
				break;

			case DESTINATION_ADDRESS_STATE:
				//if(/*address found*/)
				//{
					parsed_message.destination_address =  SH_BLE_message[DST_FRAME];
					frame_state = PROTOCOL_VERSION_AND_LENGTH_STATE;
				//}
//				else
//				{
//					frame_state = START_OF_FRAME_STATE;
//					state_machine_is_active = STATE_MACHINE_EXIT_CONDITION;
//					error_management(UNDEFINED_DESTINATION_ADDRESS);
//				}
				break;

			case PROTOCOL_VERSION_AND_LENGTH_STATE:
			//if(/*protocol found*/)
			//	{
					//use only the last 4 bits
					parsed_message.protocol_version = (SH_BLE_message[VER_LEN_FRAME] & 0xF0) >> 4;
					//frame_state = LENGTH_STATE;
			//	}
//				else
//				{
//					frame_state = START_OF_FRAME_STATE;
//					state_machine_is_active = STATE_MACHINE_EXIT_CONDITION;
//					error_management(UNDEFINED_PROTOCOL_VERSION);
//				}

					//use only the first 4 bits
					msg_length = SH_BLE_message[VER_LEN_FRAME] & 0x0F;

					if(msg_length <= MAX_PAYLOAD_LENGTH) frame_state = MESSAGE_STATE;
					else
					{
						frame_state = START_OF_FRAME_STATE;
						state_machine_is_active = STATE_MACHINE_EXIT_CONDITION;
						error_management(MESSAGE_LENGTH_OUT_OF_BOUNDS);
					}

				break;



			case MESSAGE_STATE:
				parsed_message.command = SH_BLE_message[MTYP_FRAME];

					for(uint8_t i = 0; i < msg_length; i++)
					{
						parsed_message.data[i] = SH_BLE_message[MSG_FRAME+i];
					   //error management
					}

				frame_state = CHECKSUM_STATE;
				break;

			case CHECKSUM_STATE://http://www.barrgroup.com/Embedded-Systems/How-To/CRC-Calculation-C-Code
				//do error management for crc not initialised
				//refactor crc_table
//				if(crc_table == null) error_management(CRC_IS_NOT_INITIALISED);

				// do crc check
//				crcFast


				//crc files must be modified for it to work

//				if(crc_fails)
//				{
//					error_management(CHECKSUM_FAILED);
//					state_machine_is_active = STATE_MACHINE_EXIT_CONDITION;
//				}
				frame_state = END_OF_FRAME_STATE;
				break;

			case END_OF_FRAME_STATE:
				if(SH_BLE_message[MTYP_FRAME+msg_length+2] == END_OF_FRAME_VALUE) //+2 for CHECKSUM_STATE and END_OF_FRAME_STATE
				{
					state_machine_is_active = STATE_MACHINE_EXIT_CONDITION;
					return parsed_message; // the only case in which there are no errors
				}
				else
				{
					frame_state = START_OF_FRAME_STATE;
					state_machine_is_active = STATE_MACHINE_EXIT_CONDITION;
					error_management(START_OF_FRAME_INCORRECT);
				}
				break;

			//may be optional, or used in the case of a failure to send a
			//message back to master device to re-send the data
			default:
				error_management(UNDEFINED_STATE);
				state_machine_is_active = STATE_MACHINE_EXIT_CONDITION;
				break;
		// add a critical region STOP statement if necessary

		} //switch case
	}

	error_message.message_error = true;
	return error_message;//if message allocation failed
}


//this may be for debug only to reduce memory space used
 static void error_management(uint8_t error_code)
 {
		 switch (error_code)
		 {
			 case CHECKSUM_FAILED:
				 error_messages_sendback[CHECKSUM_FAILED] = true;
				break;

			 case START_OF_FRAME_INCORRECT:
				 error_messages_sendback[START_OF_FRAME_INCORRECT] = true;
				break;

			 case UNDEFINED_SOURCE_ADDRESS:
				 error_messages_sendback[UNDEFINED_SOURCE_ADDRESS] = true;
				break;

			 case UNDEFINED_DESTINATION_ADDRESS:
				 error_messages_sendback[UNDEFINED_DESTINATION_ADDRESS] = true;
				break;

			 case UNDEFINED_PROTOCOL_VERSION:
				 error_messages_sendback[UNDEFINED_PROTOCOL_VERSION] = true;
				break;

			 case UNDEFINED_MESSAGE:
				 error_messages_sendback[UNDEFINED_MESSAGE] = true;
				break;

			 case CRC_IS_NOT_INITIALISED:
				 error_messages_sendback[CRC_IS_NOT_INITIALISED] = true;
				break;

			 case MEMORY_NOT_FREED :
				 error_messages_sendback[MEMORY_NOT_FREED] = true;
			 	break;

			 case UNDEFINED_STATE :
				 error_messages_sendback[UNDEFINED_STATE] = true;
			 	break;

			 case BUFFER_MEMORY_NOT_ALLOCATED :
				 error_messages_sendback[BUFFER_MEMORY_NOT_ALLOCATED] = true;
			 	break;

			 case INFINITE_LOOP	:
				 error_messages_sendback[INFINITE_LOOP] = true;
			 	break;

			 case MESSAGE_LENGTH_OUT_OF_BOUNDS	:
				 error_messages_sendback[MESSAGE_LENGTH_OUT_OF_BOUNDS] = true;
			 	break;

			 case END_OF_FRAME_INCORRECT	:
				 error_messages_sendback[MESSAGE_LENGTH_OUT_OF_BOUNDS] = true;
			 	break;

			 default:
				 break;
		 }
 }


//==========================================//


























